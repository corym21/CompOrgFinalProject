The goal of the cache simulator part was to get the correct cache configuration. We use the user input for tracefile, cache size, block size and level of associativity. The first function uses these values to initialize the cache. This was mostly implemented for us but we had to find the amount of sets we needed for each cache block. We first dynamically created the cache using the cache size by the given index. Then for each block we had to create a set based on associativity. For each set we set the valid and tag values. We implement the next two functions for hit or miss. In the case of a miss, we have to use the least recently used method to replace the most recently used entry. This essentially means that the LRU method will remove the least recently used frame when the cache is full. The implementation of replacement part basically percolates everything up before assigning the replacement value to the given index. In the case of a hit, we loop through the replacement values of the given index. For the update, our function finds the location of the value to be replaced, and then percolates everything up from there before replacing the value. The next function requires an address to be passed in. The index and tag of the address is found and we check to see if it is a cache hit or miss. If it is a hit, then we use the update on hit function. If a miss is found, then the replace on miss function is used. Cache hit or cache miss values are incremented respectively. The cache access value is incremented regardless so that at the end, an appropriate miss rate can be calculated. The last function (implemented for us) is used to print the cache performance including the hits, misses, and the ratio.
